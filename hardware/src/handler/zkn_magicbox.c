// SPDX-License-Identifier: MIT
// Copyright (c) 2025 ZKNOX @+

#include <stdint.h>   // uint*_t
#include <stdbool.h>  // bool
#include <stddef.h>   // size_t
#include <string.h>   // memset, explicit_bzero


#include "../sw.h"
#include "os.h"
#include "cx.h"
#include "buffer.h"

#include "../globals.h" //io_send_response_pointer
#include "../ui/display.h"

#include "zkn_errors.h"
#include "zkn_poseidon_constants.h"
#include "zkn_tEdwards.h"
#include "zkn_eddsa.h"
#include "zkn_frost.h"
#include "zkn_rfc9591frost.h"
#include "zkn_magicbox.h"

//reference sequence:0x01f2be6b2d4b290013a2e019885e0ec718dbd3d8ff68541e4d34f1727b1bb540
//expected: 0x480d65fda15f575e6740c9522bceb1ae96670c169becad5acb1c2599f07e8100
//            c80d65fda15f575e6740c9522bceb1ae96670c169becad5acb1c2599f07e8103
//e00800002001f2be6b2d4b290013a2e019885e0ec718dbd3d8ff68541e4d34f1727b1bb540
//for length=32 return the reverse troncated output as expected by ecdsa
int handler_cmd_blake2b512(buffer_t *cdata){
  uint8_t out[64];
  ZKN_ERROR_INIT();
  
  cx_blake2b_t state;

  if(cdata->size!=32){
    
     //ZKN_CHECK(cx_blake2b_512_hash(cdata->ptr,  cdata->size, out));
     
  ZKN_CHECK(cx_hash_init_ex((cx_hash_t *)&state,  CX_BLAKE2B,64));//init for a 64 bytes size output
  ZKN_CHECK(cx_hash_update((cx_hash_t *)&state, cdata->ptr,  cdata->size));//update with APDU payload
  ZKN_CHECK(cx_hash_final((cx_hash_t *)&state, out));//obtain blake512(payload) with 32 output bytes
  

     io_send_response_pointer( out, sizeof(out), SW_OK);
  }
  else{
    ZKN_CHECK(zkn_prv_hash(cdata->ptr, out, 32));
    io_send_response_pointer( out, 64, SW_OK);
  }

  
  ZKN_ERROR_CLOSE_SEND(); 
}

int handler_cmd_keccakH(buffer_t *cdata){
  uint8_t out[32];

  ZKN_ERROR_INIT();
  cx_sha3_t state;

  ZKN_CHECK(cx_hash_init_ex((cx_hash_t *)&state,  CX_KECCAK,32));//init for a 32 bytes size output
  ZKN_CHECK(cx_hash_update((cx_hash_t *)&state, cdata->ptr,  cdata->size));//update with APDU payload
  ZKN_CHECK(cx_hash_final((cx_hash_t *)&state, out));//obtain KECCAK(payload) with 32 output bytes

  io_send_response_pointer( out, 32, SW_OK);

  ZKN_ERROR_CLOSE_SEND(); 
}

/*
Fonction: cx_bn_mod_add(r, a, b, q)

a=0x05a0c09156838b9828af3f1267e175e6e284c79d1b6d8ad0cd0ae0d95790336e
b=0x0581fb4a6e4ab5a8120b8226df951e10d794d8b7705d1fb36b998eb91a4b38e5
q=0x060c89ce5c263405370a08b6d0302b0bab3eedb83920ee0a677297dc392126f1
r (attendu) = 0x516320d68a80d3b03b0b882774668ec0edab29c52a9bc79d131d7b638ba4562
r (obtenu)= 0xb22bbdbc4ce41403abac139477693f7ba19a0548bcaaa8438a46f9271db6c53

Diagnostic: absence de réduction modulaire, le résultat est a+b en place de (a+b)%q*/

int handler_cmd_bolos_stretch(){
  
  ZKN_ERROR_INIT();
  
  ZKN_CHECK(cx_bn_lock(32, 0));

  uint8_t out[32];
  uint8_t n[32]={0x06, 0x0c, 0x89, 0xce, 0x5c, 0x26, 0x34, 0x05, 0x37, 0x0a, 0x08, 0xb6, 0xd0, 0x30, 0x2b, 0x0b, 0xab, 0x3e, 0xed, 0xb8, 0x39, 0x20, 0xee, 0x0a, 0x67, 0x72, 0x97, 0xdc, 0x39, 0x21, 0x26, 0xf1};
 uint8_t a[32] = {
    0x05, 0xa0, 0xc0, 0x91, 0x56, 0x83, 0x8b, 0x98,
    0x28, 0xaf, 0x3f, 0x12, 0x67, 0xe1, 0x75, 0xe6,
    0xe2, 0x84, 0xc7, 0x9d, 0x1b, 0x6d, 0x8a, 0xd0,
    0xcd, 0x0a, 0xe0, 0xd9, 0x57, 0x90, 0x33, 0x6e
};

uint8_t b[32] = {
    0x05, 0x81, 0xfb, 0x4a, 0x6e, 0x4a, 0xb5, 0xa8,
    0x12, 0x0b, 0x82, 0x26, 0xdf, 0x95, 0x1e, 0x10,
    0xd7, 0x94, 0xd8, 0xb7, 0x70, 0x5d, 0x1f, 0xb3,
    0x6b, 0x99, 0x8e, 0xb9, 0x1a, 0x4b, 0x38, 0xe5
};

  cx_bn_t bn_n;
  cx_bn_t bn_a;
  cx_bn_t bn_b;
  cx_bn_t bn_r;

  ZKN_CHECK(cx_bn_alloc_init(&bn_n,32,n,32));
  ZKN_CHECK(cx_bn_alloc_init(&bn_a,32,a,32));
  ZKN_CHECK(cx_bn_alloc_init(&bn_b,32,b,32));
  ZKN_CHECK(cx_bn_alloc(&bn_r,32));
  
  ZKN_CHECK(cx_bn_mod_add(bn_r,bn_a,bn_b,bn_n));
  ZKN_CHECK(cx_bn_export(bn_r, out, 32));


  io_send_response_pointer( out, 32, SW_OK);
  
  
  ZKN_ERROR_CLOSE_SEND(); 
}


//single example
int handler_cmd_Poseidon(buffer_t *cdata){

  

 // R8[0]
uint8_t input[160] = {
    0x27, 0xba, 0x13, 0x84, 0xa8, 0x87, 0xc1, 0x77,    0x8a, 0x9c, 0xae, 0xb0, 0x99, 0x56, 0xa9, 0xeb,    0xaf, 0x5f, 0x0b, 0xd4, 0x6c, 0xb1, 0x24, 0xd8,    0xc0, 0x53, 0x2f, 0xc8, 0x7c, 0x3f, 0x65, 0x72,
// R8[1]
    0x01, 0x71, 0xb0, 0x46, 0xf3, 0x1b, 0xe4, 0xee,    0x72, 0x67, 0x81, 0x3b, 0x0f, 0x90, 0x68, 0x36,    0x7b, 0xf6, 0xc9, 0x92, 0x33, 0xea, 0x48, 0xc1,    0x71, 0xa5, 0x36, 0xe7, 0x95, 0x19, 0x7a, 0x53,
// A[0]
    0x07, 0xd7, 0xc9, 0x29, 0x01, 0x2d, 0x00, 0x84,    0x77, 0xb1, 0x70, 0x14, 0x22, 0x3e, 0x9b, 0x70,    0x6b, 0x6b, 0xa2, 0x25, 0xe6, 0x6a, 0x59, 0xa2,    0x50, 0x35, 0x2c, 0xf0, 0xd3, 0x9d, 0x55, 0xb6,
// A[1]
    0x2b, 0x6a, 0xc5, 0xeb, 0x59, 0x78, 0xa9, 0x26,    0x0c, 0x0d, 0xa1, 0x21, 0x93, 0x36, 0xc6, 0x39,    0xe1, 0x86, 0xf7, 0x58, 0x7a, 0x1c, 0x86, 0x40,    0xc2, 0x2a, 0xb4, 0x0f, 0xa9, 0x8f, 0x47, 0x18,
// msg
    0x05, 0x84, 0x0d, 0xc7, 0xa9, 0xd6, 0x1d, 0x52,    0xe1, 0x16, 0x4c, 0x57, 0x9f, 0xca, 0xab, 0xaf,0xcc, 0xda, 0x47, 0x7b, 0x41, 0x61, 0x5c, 0x6e, 0x7c, 0x70, 0x27, 0x82, 0x71, 0x26, 0x1f, 0x8c};
  /*expected described in eddsaposeidondetailed.txt of the repo, generated by circomlib */
 

  ZKN_ERROR_INIT();
  ZKN_CHECK(cx_bn_lock(32, 0));

  //uint64_t out[4]={1,2,3,4};
  uint8_t out[96];
  for(size_t i=0;i<sizeof(out);i++) out[i]=0xff;
  poseidon_ctx_t Ctx;
  cx_bn_mont_ctx_t montctx;
  cx_bn_t modulus;
  cx_bn_t temp;

  //babujujub modulus
  uint8_t bbjj_prime[32]={0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01};
    
  ZKN_CHECK(cx_bn_alloc_init(&modulus, 32,  bbjj_prime, 32));
  ZKN_CHECK(cx_bn_alloc_init(&temp, 32,  bbjj_prime, 32));

  ZKN_CHECK(cx_mont_alloc(&montctx, 32));//allocate Montgomery context
  ZKN_CHECK(cx_mont_init(&montctx, modulus));


  ZKN_CHECK(Poseidon_alloc_init(&Ctx, 5, 5, &montctx));
 
  
  
  
  for(size_t i=0;i<Ctx.nb_inputs;i++){
    ZKN_CHECK(cx_bn_init(Ctx.state[i+1], input+32*i, 32));
    ZKN_CHECK(cx_mont_to_montgomery(Ctx.state[i+1], Ctx.state[i+1], Ctx.mont));
    
  }
 
 Poseidon(&Ctx, 0, &temp, 1);
 
 int index=cdata->ptr[0];
 ZKN_CHECK(cx_mont_from_montgomery(Ctx.state[index], Ctx.state[index], Ctx.mont));

 ZKN_CHECK(cx_bn_export(Ctx.state[index],  out, 32));
 

 io_send_response_pointer(out, 96, SW_OK);

 ZKN_CHECK(cx_bn_destroy(&temp));
 ZKN_CHECK(cx_bn_unlock());
 ZKN_ERROR_CLOSE_SEND();//return sw error if any, or 0 if execution OK
}



//generate the i+1-th poseidon5 constant, ex: e00d00000101 = second constant
int handler_cmd_Poseidon_ithRC(buffer_t *cdata){
  ZKN_ERROR_INIT();
  ZKN_CHECK(cx_bn_lock(32, 0));

  uint64_t out[4]={1,2,3,4};

  poseidon_ctx_t Ctx;
  cx_bn_mont_ctx_t montctx;
  cx_bn_t modulus;
  //babujujub modulus
  uint8_t bbjj_prime[32]={0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01};
    
  ZKN_CHECK(cx_bn_alloc_init(&modulus, 32,  bbjj_prime, 32));
  
  ZKN_CHECK(cx_mont_alloc(&montctx, 32));//allocate Montgomery context
  ZKN_CHECK(cx_mont_init(&montctx, modulus));


  ZKN_CHECK(Poseidon_alloc_init(&Ctx, 5, 5, &montctx));
  
  size_t nconstant=(size_t) cdata->ptr[0];
  for(size_t i=0;i<nconstant;i++){
   Poseidon_getNext_RC(&Ctx, out);
  }
  
 
 io_send_response_pointer((uint8_t *) out, 32, SW_OK);


 
 ZKN_CHECK(cx_bn_unlock());
 ZKN_ERROR_CLOSE_SEND();//return sw error if any, or 0 if execution OK

}

//initialize the private/public key pair from input (wip)
int handler_cmd_tEddsaPoseidon_SetKey(buffer_t *cdata){

  ZKN_ERROR_INIT();
  
  if(cdata->size>ECC_MAXSIZE8+1)
    error= SW_WRONG_DATA_LENGTH;

  if(cdata->size<2)
    error= SW_WRONG_DATA_LENGTH;

  uint32_t curveID=cdata->ptr[0];

  uint8_t out[256];
  uint8_t in[256];

  uint8_t *ptr_key=G_context.pk_info.raw_public_key;
  uint8_t *ptr_sk=G_context.pk_info.chain_code;


  for(size_t i=0;i<256;i++){
    out[i]=0xff;
  }

  for(size_t i=0;i<cdata->size-1;i++){
    ptr_sk[i]=cdata->ptr[i+1];//store private key
  }

  ZKN_CHECK(cx_bn_lock(32, 0));
  zkn_edcurve_t curve;
  zkn_edpoint_t Kpub;
    

  ZKN_CHECK(tEdwards_Curve_alloc_init(&curve, curveID));

  ZKN_CHECK(tEdwards_alloc(&curve,  &Kpub));
  
  ZKN_CHECK(zkn_prv2pub(&curve, in, &Kpub));

  ZKN_CHECK(tEdwards_export(&curve, &Kpub, ptr_key, ptr_key+32));//shall be result 

  io_send_response_pointer(out, curve.fieldsize8*2, SW_OK);

  ZKN_CHECK(cx_bn_unlock());

  ZKN_ERROR_CLOSE_SEND(); 

}

int handler_cmd_tEddsaPoseidon_Kpub(buffer_t *cdata){
  
  ZKN_ERROR_INIT();
  


  if(cdata->size>ECC_MAXSIZE8+1)
    error= SW_WRONG_DATA_LENGTH;

  if(cdata->size<2)
    error= SW_WRONG_DATA_LENGTH;

  uint32_t curveID=cdata->ptr[0];

  uint8_t out[256];
  uint8_t in[256];

  for(size_t i=0;i<256;i++){
    out[i]=0xff;
  }

  for(size_t i=0;i<cdata->size-1;i++){
    in[i]=cdata->ptr[i+1];
  }

  ZKN_CHECK(cx_bn_lock(32, 0));
  zkn_edcurve_t curve;
  zkn_edpoint_t Kpub;
    

  ZKN_CHECK(tEdwards_Curve_alloc_init(&curve, curveID));

  ZKN_CHECK(tEdwards_alloc(&curve,  &Kpub));
  
  ZKN_CHECK(zkn_prv2pub(&curve, in, &Kpub));

  ZKN_CHECK(tEdwards_export(&curve, &Kpub, out, out+32));//shall be result 

  io_send_response_pointer(out, curve.fieldsize8*2, SW_OK);

  ZKN_CHECK(cx_bn_unlock());

  ZKN_ERROR_CLOSE_SEND(); 
}


int handler_cmd_tEddsaPoseidon_Sign(buffer_t *cdata){
   ZKN_ERROR_INIT();

  

  //size is curveID(1)|| prv(32) || msg(32)
  if(cdata->size!=65)
    error= SW_WRONG_DATA_LENGTH;

  uint32_t curveID=cdata->ptr[0];

  uint8_t out[256];
  uint8_t in[256];

  for(size_t i=0;i<256;i++){
    out[i]=0xff;
  }

  for(size_t i=0;i<cdata->size-1;i++){
    in[i]=cdata->ptr[i+1];
  }

  ZKN_CHECK(cx_bn_lock(32, 0));
  zkn_edcurve_t curve;
  zkn_edpoint_t Kpub;
  

  uint8_t prv[32]/*={0x00, 0xa2, 0xac, 0x13, 0xcd, 0xba, 0x83, 0x0a, 0x55, 0xbf, 0x40, 0x7e, 0xa7, 0x0c, 0x5f, 0xd2, 0x93, 0x12, 0xc1, 0x70, 0x60, 0xf0, 0x7d, 0x35, 0xfe, 0xa5, 0xde, 0x47, 0xd6, 0xc0, 0x3e, 0xd2}*/;
  uint8_t msg[32]/*={0x8c, 0x1f, 0x26, 0x71, 0x82, 0x27, 0x70, 0x7c, 0x6e, 0x5c, 0x61, 0x41, 0x7b, 0x47, 0xda, 0xcc, 0xaf, 0xab, 0xca, 0x9f, 0x57, 0x4c, 0x16, 0xe1, 0x52, 0x1d, 0xd6, 0xa9, 0xc7, 0x0d, 0x84, 0x05}*/;


  for(size_t i=0;i<32;i++){
    prv[i]=cdata->ptr[1+i]; //offset curveID
    msg[i]=cdata->ptr[33+i];//offset curveID+prv
  }


  ZKN_CHECK(tEdwards_Curve_alloc_init(&curve, curveID));
  

  ZKN_CHECK(tEdwards_alloc(&curve,  &Kpub));


  ZKN_CHECK(zkn_prv2pub(&curve, in, &Kpub));

  ZKN_CHECK(tEdwards_export(&curve, &Kpub, out, out+32));//shall be result kpub

  ZKN_CHECK(EddsaPoseidon_Sign_final(&curve,  prv, &Kpub, msg, 32, out));

  io_send_response_pointer(out, 96, SW_OK);//answer is R8x, R8y, S

  
  ZKN_CHECK(cx_bn_unlock());

  ZKN_ERROR_CLOSE_SEND(); 
}



int handler_cmd_tEddsaPoseidon(buffer_t *cdata){
  //allocate the Edwards structure
  
  ZKN_ERROR_INIT();

  if(cdata->size>ECC_MAXSIZE8+1)
    error= SW_WRONG_DATA_LENGTH;

  if(cdata->size<2)
    error= SW_WRONG_DATA_LENGTH;

  uint32_t curveID=cdata->ptr[0];
  bool flag;

  uint8_t out[256];
  uint8_t in[256];

  for(size_t i=0;i<256;i++){
    out[i]=0xff;
  }

  for(size_t i=0;i<cdata->size;i++){
    in[i]=cdata->ptr[i+1];
  }


  ZKN_CHECK(cx_bn_lock(32, 0));
  zkn_edcurve_t curve;
  zkn_edpoint_t edG;


  
  
  //ZKN_CHECK(zkn_prv_hash(cdata->ptr+1, out, 32));
  

  ZKN_CHECK(tEdwards_Curve_alloc_init(&curve, curveID));

  ZKN_CHECK(tEdwards_IsOnCurve(&curve, &curve.G, &flag));
  if(flag!=true)
    return io_send_sw(0xca01);
    

  uint8_t bbjj_R8x[32]={0x0b, 0xb7, 0x7a, 0x6a, 0xd6, 0x3e, 0x73, 0x9b, 0x4e, 0xac, 0xb2, 0xe0, 0x9d, 0x62, 0x77, 0xc1, 0x2a, 0xb8, 0xd8, 0x01, 0x05, 0x34, 0xe0, 0xb6, 0x28, 0x93, 0xf3, 0xf6, 0xbb, 0x95, 0x70, 0x51};
  uint8_t bbjj_R8y[32]={0x25, 0x79, 0x72, 0x03, 0xf7, 0xa0, 0xb2, 0x49, 0x25, 0x57, 0x2e, 0x1c, 0xd1, 0x6b, 0xf9, 0xed, 0xfc, 0xe0, 0x05, 0x1f, 0xb9, 0xe1, 0x33, 0x77, 0x4b, 0x3c, 0x25, 0x7a, 0x87, 0x2d, 0x7d, 0x8b};
     
  ZKN_CHECK(tEdwards_alloc_init(&curve, bbjj_R8x, bbjj_R8y, &edG));

  ZKN_CHECK(tEdwards_IsOnCurve(&curve, &curve.G, &flag));
  if(flag!=true)
    return io_send_sw(0xca01);
  

  ZKN_CHECK(tEdwards_scalarMul(&curve, &curve.G, cdata->ptr+1, cdata->size-1, &edG));//compute the scalar multiplication of input data
  ZKN_CHECK(tEdwards_export(&curve, &edG, out, out+64));//shall be result 


  io_send_response_pointer(out, sizeof(out), SW_OK);

  ZKN_CHECK(cx_bn_unlock());

  ZKN_ERROR_CLOSE_SEND(); 
}


//apdu syntax           e00e0000|size+1|id|scalar
//where size is the size of the scalar in bytes

//example commands: e00e0000020101, multiply P by 1 on bandersnatch
//bandersnatch test: e00e000021011cfb69d4ca675f520cce760202687600ff8f87007419047174fd06b52876e7e2 is (order+1)P, shall return P
//babyjujub test:    e00e00002102060c89ce5c263405370a08b6d0302b0bab3eedb83920ee0a677297dc392126f2 is (order+1)P, shall return P

int handler_cmd_tEdwards(buffer_t *cdata){
  ZKN_ERROR_INIT();
  
  if(cdata->size>ECC_MAXSIZE8+1)
    return SW_WRONG_DATA_LENGTH;

  if(cdata->size<2)
    return SW_WRONG_DATA_LENGTH;

  uint32_t curveID=cdata->ptr[0];
 
  uint8_t out[256];
  for(int i=0;i<256;i++){
    out[i]=0xff;
  }
  ZKN_CHECK(cx_bn_lock(32, 0));
  zkn_edcurve_t curve;
  //cx_trng_init();

  ZKN_CHECK(tEdwards_Curve_alloc_init(&curve, curveID));


  zkn_edpoint_t edP;
  zkn_edpoint_t edQ;
  
  if(curveID==_BANDERSNATCH_ID){
  //from ZKNOX PyBandersnatch
  //test_vectors['p'] = E(F(0x1cc6ee38139c1c110223537a8ce79d067e58cc1067c6fbb7d8b3a1b08dfc8f08), F(0x70a5894a64445438d015ac32ba360f092cde44bab11fc2b7d4b5c0d216228cce), F(1))
  uint8_t px[32]={0x1c, 0xc6, 0xee, 0x38, 0x13, 0x9c, 0x1c, 0x11, 0x02, 0x23, 0x53, 0x7a, 0x8c, 0xe7, 0x9d, 0x06, 0x7e, 0x58, 0xcc, 0x10, 0x67, 0xc6, 0xfb, 0xb7, 0xd8, 0xb3, 0xa1, 0xb0, 0x8d, 0xfc, 0x8f, 0x08};
  uint8_t py[32]={0x70, 0xa5, 0x89, 0x4a, 0x64, 0x44, 0x54, 0x38, 0xd0, 0x15, 0xac, 0x32, 0xba, 0x36, 0x0f, 0x09, 0x2c, 0xde, 0x44, 0xba, 0xb1, 0x1f, 0xc2, 0xb7, 0xd4, 0xb5, 0xc0, 0xd2, 0x16, 0x22, 0x8c, 0xce};

  
 // test_vectors['p_double'] = E(F(0x604a025084bdae7f6d83c3de82b41b840118cca2b4431bb1c9140190b705fea8), F(0x3e8ff40606be05404b97ccdefb19956b75ab0b532da07edf5d6b4f6a404b06cf), F(1))
 // test_vectors['p_plus_q'] = E(F(0x14d5319b5a0aee4d5ad410a5965e4f46c04b034f10252edc887567d206e762fb), F(0x2d04373af410d24b4bb950f8b3096928852705ab12c7e7b46611fac016328df9), F(1))
 //test_vectors['k'] = 0x1a862619b8224e61eb24bb583c84ce04913064d37308623924c7a64fcdc9f191
 //test_vectors['k_times_p'] = E(F(0x5e68a7f103de3be399640801563ddcaac8fc2fa31b413df3a8ae975ace0dc465), F(0xf2693e9239ee3709661fbf6c908de99ce7a41f149cefebe5ef6fc2c292bb4c6), F(1))s

  //test_vectors['q'] = E(F(0x2a2086fc8de76abcc75c48528de91cf68fb8ce4c04f80b94b071315dfff66db8), F(0x6765f125acbdd10815bedbffe1147d36cf5c501f7ad467f4cd12aeec62a7ef1f), F(1))
  //uint8_t qx[32]={0x2a, 0x20, 0x86, 0xfc, 0x8d, 0xe7, 0x6a, 0xbc, 0xc7, 0x5c, 0x48, 0x52, 0x8d, 0xe9, 0x1c, 0xf6, 0x8f, 0xb8, 0xce, 0x4c, 0x04, 0xf8, 0x0b, 0x94, 0xb0, 0x71, 0x31, 0x5d, 0xff, 0xf6, 0x6d, 0xb8};
  //uint8_t qy[32]={0x67, 0x65, 0xf1, 0x25, 0xac, 0xbd, 0xd1, 0x08, 0x15, 0xbe, 0xdb, 0xff, 0xe1, 0x14, 0x7d, 0x36, 0xcf, 0x5c, 0x50, 0x1f, 0x7a, 0xd4, 0x67, 0xf4, 0xcd, 0x12, 0xae, 0xec, 0x62, 0xa7, 0xef, 0x1f};


   ZKN_CHECK(tEdwards_alloc_init(&curve, px, py, &edP));
   ZKN_CHECK(tEdwards_alloc_init(&curve, px, py, &edQ));
  }

  //not tested
  if(curveID==_BABYJUJUB_ID){
  
  //tbd:https://github.com/iden3/go-iden3-crypto/blob/master/babyjub/babyjub_test.go
  //aX=17777552123799933955779906779655732241715742912184938656739573121738514868268
  //0x274dbce8d15179969bc0d49fa725bddf9de555e0ba6a693c6adb52fc9ee7a82c
  //aY=2626589144620713026669568689430873010625803728049924121243784502389097019475
  //0x5ce98c61b05f47fe2eae9a542bd99f6b2e78246231640b54595febfd51eb853

  //test_vectors['p'] = E(F(0x1cc6ee38139c1c110223537a8ce79d067e58cc1067c6fbb7d8b3a1b08dfc8f08), F(0x70a5894a64445438d015ac32ba360f092cde44bab11fc2b7d4b5c0d216228cce), F(1))
  uint8_t px2[32]={0x27, 0x4d, 0xbc, 0xe8, 0xd1, 0x51, 0x79, 0x96, 0x9b, 0xc0, 0xd4, 0x9f, 0xa7, 0x25, 0xbd, 0xdf, 0x9d, 0xe5, 0x55, 0xe0, 0xba, 0x6a, 0x69, 0x3c, 0x6a, 0xdb, 0x52, 0xfc, 0x9e, 0xe7, 0xa8, 0x2c};
  uint8_t py2[32]={0x05, 0xce, 0x98, 0xc6, 0x1b, 0x05, 0xf4, 0x7f, 0xe2, 0xea, 0xe9, 0xa5, 0x42, 0xbd, 0x99, 0xf6, 0xb2, 0xe7, 0x82, 0x46, 0x23, 0x16, 0x40, 0xb5, 0x45, 0x95, 0xfe, 0xbf, 0xd5, 0x1e, 0xb8, 0x53};


  
 

   ZKN_CHECK(tEdwards_alloc_init(&curve, px2, py2, &edP));
   ZKN_CHECK(tEdwards_alloc_init(&curve, px2, py2, &edQ));
  }

 bool flag=false;

 ZKN_CHECK(tEdwards_IsOnCurve(&curve, &edP, &flag));
 if(flag!=true)
    return io_send_sw(0xca01);

 ZKN_CHECK(tEdwards_IsOnCurve(&curve, &edQ, &flag));
 if(flag!=true)
    return io_send_sw(0xca02);

ZKN_CHECK(cx_bn_is_prime(curve.modulus, &flag));
if(flag!=true)
    return io_send_sw(0xca03);


ZKN_CHECK(cx_bn_is_prime(curve.order, &flag));
if(flag!=true)
    return io_send_sw(0xca04);




ZKN_CHECK(tEdwards_scalarMul(&curve, &edP, cdata->ptr+1, cdata->size-1, &edQ));//compute the scalar multiplication of input data
ZKN_CHECK(tEdwards_export(&curve, &edQ, out, out+32));//shall be result 

ZKN_CHECK(cx_bn_unlock());


  io_send_response_pointer(out, curve.fieldsize8*2, SW_OK);

 ZKN_ERROR_CLOSE_SEND();//return sw error if any, or 0 if execution OK
}

/*
p=0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001;
is_prime(p);
Fp=GF(p);
cA=Fp(52435875175126190479447740508185965837690552500527637822603658699938581184508);
cD=Fp(45022363124591815672509500913686876175488063829319466900776701791074614335719);
x=Fp(0x1cc6ee38139c1c110223537a8ce79d067e58cc1067c6fbb7d8b3a1b08dfc8f08);
y=Fp(0x70a5894a64445438d015ac32ba360f092cde44bab11fc2b7d4b5c0d216228cce);

cA*x*x+y*y-(1+(cD*(x*x*y*y)))
*/


int handler_cmd_Interpolate_back(buffer_t *cdata){
   ZKN_ERROR_INIT();


  if(cdata->size<2)
    error= SW_WRONG_DATA_LENGTH;

  uint32_t curveID=cdata->ptr[0];
  //bool flag;

  uint8_t out[256];
  //uint8_t in[256];

  for(size_t i=0;i<256;i++){
    out[i]=0xff;
  }

  ZKN_CHECK(cx_bn_lock(32, 0));
  zkn_edcurve_t curve;
  
  //ZKN_CHECK(zkn_prv_hash(cdata->ptr+1, out, 32));
  
  
  ZKN_CHECK(tEdwards_Curve_alloc_init(&curve, curveID));

  //Secret Polynomial P(x) = a0 + a1*x + a2*x^2:
  
  uint8_t coeff[96]=  { 
     0x04, 0x35, 0x83, 0xe3, 0x3f, 0xb2, 0xf4, 0x7f, 0xaa, 0x24, 0x3b, 0x5c, 0xdf, 0x8c, 0xb2, 0x51, 0xf7, 0xe9, 0x48, 0x2f, 0x03, 0x86, 0x06, 0x49, 0x01, 0xae, 0x0c, 0x5e, 0x21, 0x34, 0xb7, 0x8f,//a0
     0x05, 0x7e, 0xa5, 0x1a, 0x2f, 0x57, 0x12, 0x86, 0x1d, 0x3e, 0x31, 0x25, 0xc7, 0xb8, 0x1f, 0x08, 0x1b, 0x19, 0xc4, 0x0b, 0x04, 0x89, 0x4a, 0xbf, 0x76, 0xd3, 0x54, 0x29, 0xf2, 0xee, 0xf8, 0xa3,//a1
     0x04, 0x39, 0x10, 0x9f, 0x6f, 0x29, 0x46, 0x25, 0x7f, 0x8c, 0x50, 0x87, 0x18, 0xb4, 0xa8, 0x6e, 0x0c, 0xc7, 0x3e, 0x1c, 0xae, 0x22, 0xdd, 0x0b, 0x7b, 0x8a, 0x20, 0xa5, 0x93, 0x31, 0xd5, 0xb4};//a2
 
  cx_bn_t secretPolynomial[3];
  for(size_t i=0;i<3;i++){
     ZKN_CHECK(cx_bn_alloc_init(&secretPolynomial[i], 32, coeff+32*i,32));
  }
  
  zkn_edpoint_t Pubkeys[4];

  cx_bn_t ski;
  cx_bn_t Idi;
  cx_bn_t skis[4];  
  cx_bn_t Ids[4];
 
   ZKN_CHECK(cx_bn_alloc(&ski, 32));
   ZKN_CHECK(cx_bn_alloc(&Idi, 32));


    //Secret Shares and Public Key Shares:
  
    for(uint32_t i=0;i<4;i++){  
     
     ZKN_CHECK(cx_bn_alloc(&skis[i], 32));
     ZKN_CHECK(cx_bn_alloc(&Ids[i], 32));
    
     ZKN_CHECK( cx_bn_set_u32(Idi, i));
     ZKN_CHECK( cx_bn_set_u32(Ids[i], i));
     
     ZKN_CHECK(tEdwards_alloc(&curve, &Pubkeys[i])); 
     ZKN_CHECK(zkn_evalshare(&curve, secretPolynomial, 2, Idi, ski));
     ZKN_CHECK(cx_bn_copy(skis[i], ski));
     ZKN_CHECK(tEdwards_scalarMul_bn(&curve, &curve.G, &ski, &Pubkeys[i]));
     ZKN_CHECK(tEdwards_normalize(&curve, &Pubkeys[i]));

     //ZKN_CHECK(tEdwards_export(&curve, &Pubkeys[i], out+64*i, out+64*i+32));//tested ok
     

     //ZKN_CHECK(cx_bn_export(ski, out+64*i, 32));
  }


   for(size_t i=0;i<3;i++)  ZKN_CHECK(cx_bn_destroy(&secretPolynomial[i]));
    ZKN_CHECK(zkn_frost_interpolate_secrets(&curve, Ids+1, skis+1, 3, ski));

  ZKN_CHECK(cx_bn_export(ski, out+224, 32));
    
  io_send_response_pointer(out, sizeof(out), SW_OK);

  ZKN_CHECK(cx_bn_unlock());

  ZKN_ERROR_CLOSE_SEND();
}

      
 

  
int handler_cmd_Interpolate(buffer_t *cdata){
   ZKN_ERROR_INIT();


  if(cdata->size<2)
    error= SW_WRONG_DATA_LENGTH;

  uint32_t curveID=cdata->ptr[0];
  //bool flag;

  uint8_t out[256];

  for(size_t i=0;i<256;i++){
    out[i]=0xff;
  }

  ZKN_CHECK(cx_bn_lock(32, 0));
  zkn_edcurve_t curve;
  
  //ZKN_CHECK(zkn_prv_hash(cdata->ptr+1, out, 32));
  
  
  ZKN_CHECK(tEdwards_Curve_alloc_init(&curve, curveID));

  //Secret Polynomial P(x) = a0 + a1*x + a2*x^2:
  
 
  cx_bn_t skis[3];  
  cx_bn_t Ids[3];
 
  cx_bn_t mastersk;
  ZKN_CHECK(cx_bn_alloc(&mastersk, 32));

  
uint8_t secrets[96]; /*= {
    0x02, 0x96, 0xbc, 0x42, 0x5a, 0xd6, 0xb8, 0x65,
    0x4c, 0xb4, 0x1e, 0x6e, 0x7a, 0xdf, 0x68, 0x08,
    0xc9, 0x3d, 0x4b, 0x94, 0x8c, 0xed, 0x1e, 0x40,
    0x57, 0xfd, 0xff, 0xae, 0xae, 0xde, 0x48, 0x1d,
    0x01, 0xce, 0x53, 0x5c, 0xdf, 0x2d, 0x2c, 0x2e,
    0x41, 0x75, 0x45, 0x80, 0x1c, 0xce, 0xa3, 0x00,
    0x3a, 0x9f, 0x2a, 0x44, 0x23, 0x2d, 0xc6, 0xcc,
    0x6b, 0xfc, 0x5d, 0x90, 0xe4, 0x7a, 0x7b, 0x5e,
    0x01, 0x05, 0xea, 0x77, 0x63, 0x83, 0x9f, 0xf7,
    0x36, 0x36, 0x6c, 0x91, 0xbe, 0xbd, 0xdd, 0xf7,
    0xac, 0x01, 0x08, 0xf3, 0xb9, 0x6e, 0x6f, 0x58,
    0x7f, 0xfa, 0xbb, 0x73, 0x1a, 0x16, 0xae, 0x9f,
  };*/


  for(size_t i=0;i<96;i++){
    secrets[i]=cdata->ptr[i+1];
  }


  for(size_t i=0;i<3;i++){
     ZKN_CHECK(cx_bn_alloc_init(&skis[i], 32, secrets+32*i,32));
  }
  
  zkn_edpoint_t Pubkeys[4];



    //Secret Shares and Public Key Shares:
  
    for(uint32_t i=0;i<3;i++){  
     
     ZKN_CHECK(cx_bn_alloc(&Ids[i], 32));
     ZKN_CHECK( cx_bn_set_u32(Ids[i], i+1));
     
     ZKN_CHECK(tEdwards_alloc(&curve, &Pubkeys[i])); 

     ZKN_CHECK(tEdwards_scalarMul_bn(&curve, &curve.G, &skis[i], &Pubkeys[i]));
     ZKN_CHECK(cx_bn_export(Ids[i], out+64*i, 32));
     ZKN_CHECK(cx_bn_export(skis[i], out+64*i+32, 32));


     ZKN_CHECK(tEdwards_normalize(&curve, &Pubkeys[i]));

     //ZKN_CHECK(tEdwards_export(&curve, &Pubkeys[i], out+64*i, out+64*i+32));//tested ok
     

     //ZKN_CHECK(cx_bn_export(ski, out+64*i, 32));
  }


  ZKN_CHECK(zkn_frost_interpolate_secrets(&curve, Ids, skis, 3, mastersk));
  ZKN_CHECK(cx_bn_export(mastersk, out+192, 32));

  ZKN_CHECK(tEdwards_scalarMul_bn(&curve, &curve.G, &mastersk, &Pubkeys[0]));
  ZKN_CHECK(tEdwards_export(&curve, &Pubkeys[0], out+224, secrets));//tested ok
      
    //0x1e01fab142fe45077ff7a260c5ef24eab10daec9b7f328de395a8d0f8d1fd8e2

  io_send_response_pointer(out, sizeof(out), SW_OK);

  ZKN_CHECK(cx_bn_unlock());

  ZKN_ERROR_CLOSE_SEND();
}



//split, for now degree is set to 2
int handler_cmd_Split(buffer_t *cdata){
   ZKN_ERROR_INIT();


  if(cdata->size<2)
    error= SW_WRONG_DATA_LENGTH;

  uint32_t curveID=cdata->ptr[0];
  size_t len=cdata->ptr[1];//

  if(len>3)
    error= SW_WRONG_DATA_LENGTH;
  
  uint8_t out[256];
  
  for(size_t i=0;i<256;i++){
    out[i]=0xff;
  }

  ZKN_CHECK(cx_bn_lock(32, 0));
  zkn_edcurve_t curve;
  
  
  
  ZKN_CHECK(tEdwards_Curve_alloc_init(&curve, curveID));

  //Secret Polynomial P(x) = a0 + a1*x + a2*x^2:
  
  uint8_t coeff[96];

  for(size_t i=0;i<32;i++) coeff[i]= cdata->ptr[i+2];

  ZKN_CHECK(cx_blake2b_512_hash(cdata->ptr+2,  cdata->size-2, coeff+32));//replace to match any degree
 
  cx_bn_t secretPolynomial[3];
  for(size_t i=0;i<3;i++){
     ZKN_CHECK(cx_bn_alloc_init(&secretPolynomial[i], 32, coeff+32*i,32));
  }
  
  zkn_edpoint_t Pubkeys[4];

  #define MAX_NSHARE 4

  cx_bn_t ski;
  cx_bn_t Idi;
  cx_bn_t skis[MAX_NSHARE];  
  cx_bn_t Ids[MAX_NSHARE];
 
  ZKN_CHECK(cx_bn_alloc(&ski, 32));
  ZKN_CHECK(cx_bn_alloc(&Idi, 32));


    //Secret Shares and Public Key Shares:
  
    for(uint32_t i=0;i<MAX_NSHARE;i++){  
     
     ZKN_CHECK(cx_bn_alloc(&skis[i], 32));
     ZKN_CHECK(cx_bn_alloc(&Ids[i], 32));
    
     ZKN_CHECK( cx_bn_set_u32(Idi, i));
     ZKN_CHECK( cx_bn_set_u32(Ids[i], i));
     
     ZKN_CHECK(tEdwards_alloc(&curve, &Pubkeys[i])); 
     ZKN_CHECK(zkn_evalshare(&curve, secretPolynomial, 2, Idi, ski));
     ZKN_CHECK(cx_bn_copy(skis[i], ski));
     //ZKN_CHECK(tEdwards_scalarMul_bn(&curve, &curve.G, &ski, &Pubkeys[i]));
     ZKN_CHECK(tEdwards_normalize(&curve, &Pubkeys[i]));

     //ZKN_CHECK(tEdwards_export(&curve, &Pubkeys[i], out+64*i, out+64*i+32));//tested ok
     
     ZKN_CHECK(cx_bn_export(Idi, out+64*i, 32));
     ZKN_CHECK(cx_bn_export(ski, out+64*i+32, 32));
  }


   for(size_t i=0;i<3;i++) ZKN_CHECK(cx_bn_destroy(&secretPolynomial[i]));
    ZKN_CHECK(zkn_frost_interpolate_secrets(&curve, Ids+1, skis+1, 3, ski));

  //ZKN_CHECK(cx_bn_export(ski, out+224, 32));
    
  io_send_response_pointer(out, sizeof(out), SW_OK);

  ZKN_CHECK(cx_bn_unlock());

  ZKN_ERROR_CLOSE_SEND();
}

//this apdu returns the hash with H1 to H5 of a message, tested against curves-lite ok
int handler_cmd_frostH(buffer_t *cdata){
  ZKN_ERROR_INIT();

  uint8_t out[256];
  
  ZKN_CHECK(cx_bn_lock(32, 0));
  zkn_edcurve_t curve;
  uint32_t curveID=cdata->ptr[0];
  
  ZKN_CHECK(tEdwards_Curve_alloc_init(&curve, curveID));

  cx_bn_t hash;
  ZKN_CHECK(cx_bn_alloc(&hash,32));

  ZKN_CHECK(Babyfrost_H1(cdata->ptr+1, cdata->size-1, curve.order,hash));
  ZKN_CHECK(cx_bn_export(hash, out, 32));
  ZKN_CHECK(Babyfrost_H3(cdata->ptr+1, cdata->size-1, curve.order,  hash));
  ZKN_CHECK(cx_bn_export(hash, out+32, 32));
  
  ZKN_CHECK(Babyfrost_H4(cdata->ptr+1, cdata->size-1, curve.order, hash));
  ZKN_CHECK(cx_bn_export(hash, out+64, 32));
  ZKN_CHECK(Babyfrost_H5(cdata->ptr+1, cdata->size-1, curve.order,  hash));
  ZKN_CHECK(cx_bn_export(hash, out+96, 32));
  
  ZKN_CHECK(cx_bn_export(curve.order, out+224, 32));
  io_send_response_pointer(out, sizeof(out), SW_OK);

  ZKN_CHECK(cx_bn_unlock());


  ZKN_ERROR_CLOSE_SEND();
}

//a single encodeCommitment test, problem to solve: clumsy railgun mixed encoding
int handler_cmd_encodeCommitment(buffer_t *cdata){

ZKN_ERROR_INIT();

  uint8_t out[256];
  
  ZKN_CHECK(cx_bn_lock(32, 0));
  zkn_edcurve_t curve;
  uint32_t curveID=cdata->ptr[0];
  
  ZKN_CHECK(tEdwards_Curve_alloc_init(&curve, curveID));
 
cx_bn_t H;

  ZKN_CHECK(cx_bn_alloc(&H,32));
 
  /*
 //generated 301025 from rfc8032 curves lite renaud branch 
 uint8_t commitmentlist_le[32*9]={//mixed encoding with wrong packing before railgun solves it, Ids are LE, packed point are BE , generated by curves-lite
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0xd6, 0x5d, 0xaa, 0xc0, 0x65, 0xad, 0x43, 0x54, 0x63, 0xa8, 0x4d, 0xac, 0x3c, 0xbe, 0x00, 0xd6, 0xe9, 0x63, 0xdc, 0x71, 0x5e, 0x45, 0x6e, 0x31, 0x3d, 0xb2, 0xb4, 0x8b, 0x19, 0x4f, 0xcb, 0xa5,
   0x97, 0x6c, 0x99, 0x28, 0x8e, 0x6c, 0x8f, 0x10, 0xa2, 0xb7, 0xeb, 0x76, 0xcf, 0x1c, 0x48, 0xdd, 0x0f, 0x3d, 0xe4, 0xcf, 0x98, 0xb2, 0x68, 0x86, 0x0f, 0x8e, 0xd8, 0x23, 0xa9, 0x05, 0x11, 0x05,
   0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x9e, 0xa9, 0xa8, 0xa2, 0x72, 0xe1, 0xdf, 0x45, 0xc7, 0xb2, 0xa3, 0x1b, 0xde, 0xb1, 0x8f, 0x2a, 0x58, 0x33, 0x6f, 0x64, 0x76, 0x24, 0xbd, 0x1a, 0x41, 0xe9, 0x19, 0x3a, 0x6d, 0x26, 0x56, 0xa1,
   0xf1, 0x13, 0x90, 0x4d, 0xb2, 0x86, 0xac, 0x4f, 0x83, 0x06, 0x09, 0x8d, 0x6b, 0xc6, 0x8f, 0xf1, 0x13, 0x2e, 0x88, 0x96, 0x53, 0x5e, 0xae, 0xbd, 0x50, 0xed, 0xf2, 0x4e, 0x3f, 0x0e, 0x00, 0x00,
   0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0xa1, 0xa5, 0x42, 0xeb, 0x7a, 0x07, 0x7b, 0x4f, 0xb7, 0xea, 0x5d, 0x93, 0x0d, 0xfa, 0xac, 0x40, 0x1e, 0xc6, 0x85, 0xac, 0xd8, 0x09, 0x6a, 0xf2, 0xa0, 0x09, 0x84, 0xda, 0xc5, 0xd0, 0x43, 0x8f,
   0x9f, 0xfb, 0x9b, 0x44, 0x7c, 0x49, 0xe5, 0xc9, 0x0b, 0x4c, 0x0a, 0x91, 0x9c, 0xa6, 0x31, 0x9b, 0xfe, 0x30, 0xc2, 0x1c, 0x73, 0x5d, 0x36, 0x41, 0xdf, 0x02, 0xee, 0x77, 0x63, 0x6c, 0x7e, 0x8a
 };

 //straight hash
 //Babyfrost_H5(commitmentlist_le, sizeof(commitmentlist_le), curve.order, H );//straight from curves-lite

 ZKN_CHECK(cx_bn_export(H, out+96, 32));
    //result after H5:1608891567339316258001241896205464226486714342477124965477354800622065363333n=0x38e99b0f9408c4b72ab0b2d46aff4115a3a304f2c5b0c6934daa3b40ebf2985,tested ok



 //init/update/final version (should be equal)

  cx_blake2b_t state;

  ZKN_CHECK(zkn_frost_H5_init((cx_hash_t*) &state));
  ZKN_CHECK(zkn_frost_hash_update((cx_hash_t*)&state, commitmentlist_le, sizeof(commitmentlist_le)));
  //ZKN_CHECK(zkn_frost_hash_final((cx_hash_t*)&state, curve.order, H));
  
  ZKN_CHECK(cx_bn_export(H, out+64, 32));
 */
 
 uint8_t commitmentlist_be[32*15]={//corresponding  big endian, unpacked
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
   0x11, 0x7e, 0xb1, 0xd3, 0x5d, 0x23, 0x77, 0xf0, 0xb2, 0x31, 0x32, 0x9f, 0xd5, 0xc8, 0x12, 0xa2, 0xb0, 0xde, 0xab, 0x55, 0xd1, 0x27, 0x4b, 0xf0, 0xd7, 0x54, 0xb5, 0x4e, 0x09, 0x77, 0x74, 0xf5,
   0x25, 0xcb, 0x4f, 0x19, 0x8b, 0xb4, 0xb2, 0x3d, 0x31, 0x6e, 0x45, 0x5e, 0x71, 0xdc, 0x63, 0xe9, 0xd6, 0x00, 0xbe, 0x3c, 0xac, 0x4d, 0xa8, 0x63, 0x54, 0x43, 0xad, 0x65, 0xc0, 0xaa, 0x5d, 0xd6,
   0x0d, 0xfc, 0xc3, 0x93, 0xfe, 0x01, 0x8d, 0xe7, 0x2b, 0xdc, 0xc4, 0x2f, 0xe4, 0xe1, 0xdf, 0xb7, 0xff, 0xb8, 0xc4, 0x2e, 0xbe, 0x2a, 0xe8, 0x6c, 0xe2, 0x33, 0xc4, 0x14, 0xfd, 0x01, 0x0f, 0xc0,
   0x05, 0x11, 0x05, 0xa9, 0x23, 0xd8, 0x8e, 0x0f, 0x86, 0x68, 0xb2, 0x98, 0xcf, 0xe4, 0x3d, 0x0f, 0xdd, 0x48, 0x1c, 0xcf, 0x76, 0xeb, 0xb7, 0xa2, 0x10, 0x8f, 0x6c, 0x8e, 0x28, 0x99, 0x6c, 0x97,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
   0x15, 0xdf, 0xad, 0xea, 0xd3, 0xf4, 0xc7, 0xac, 0x0f, 0xa8, 0xe7, 0x20, 0xe7, 0xad, 0x42, 0xcb, 0xe5, 0x0c, 0x5b, 0x58, 0xa7, 0xb8, 0x7e, 0x22, 0x86, 0x51, 0xb7, 0x14, 0xcc, 0x3b, 0x07, 0x15,
   0x21, 0x56, 0x26, 0x6d, 0x3a, 0x19, 0xe9, 0x41, 0x1a, 0xbd, 0x24, 0x76, 0x64, 0x6f, 0x33, 0x58, 0x2a, 0x8f, 0xb1, 0xde, 0x1b, 0xa3, 0xb2, 0xc7, 0x45, 0xdf, 0xe1, 0x72, 0xa2, 0xa8, 0xa9, 0x9e,
   0x26, 0x9a, 0xf7, 0x52, 0x1d, 0x23, 0x84, 0xfe, 0x35, 0xf9, 0xb6, 0x9d, 0x69, 0xc8, 0xf9, 0x8f, 0xfa, 0xce, 0x90, 0xb6, 0x2c, 0xd4, 0x20, 0x49, 0x55, 0x45, 0x18, 0x8b, 0x49, 0x2f, 0x5e, 0x78,
   0x00, 0x00, 0x0e, 0x3f, 0x4e, 0xf2, 0xed, 0x50, 0xbd, 0xae, 0x5e, 0x53, 0x96, 0x88, 0x2e, 0x13, 0xf1, 0x8f, 0xc6, 0x6b, 0x8d, 0x09, 0x06, 0x83, 0x4f, 0xac, 0x86, 0xb2, 0x4d, 0x90, 0x13, 0xf1,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
   0x22, 0x04, 0xf0, 0x55, 0x56, 0x3b, 0x12, 0x5d, 0x15, 0xa9, 0xbf, 0x32, 0xf3, 0x47, 0x8e, 0xf7, 0xa5, 0x72, 0x9a, 0x06, 0x26, 0xb0, 0x0d, 0x59, 0xec, 0xd0, 0x03, 0x3d, 0x3d, 0xa8, 0x15, 0x15,
   0x0f, 0x43, 0xd0, 0xc5, 0xda, 0x84, 0x09, 0xa0, 0xf2, 0x6a, 0x09, 0xd8, 0xac, 0x85, 0xc6, 0x1e, 0x40, 0xac, 0xfa, 0x0d, 0x93, 0x5d, 0xea, 0xb7, 0x4f, 0x7b, 0x07, 0x7a, 0xeb, 0x42, 0xa5, 0xa1,
   0x29, 0x96, 0xb5, 0x76, 0x71, 0xff, 0x5b, 0x9c, 0xbd, 0x44, 0x5a, 0x7e, 0x9a, 0x35, 0x4e, 0xb0, 0x6a, 0xa8, 0xe0, 0x98, 0x2d, 0x92, 0x18, 0x38, 0xc9, 0xd9, 0xb1, 0xa8, 0xee, 0x94, 0xf5, 0x99,
   0x0a, 0x7e, 0x6c, 0x63, 0x77, 0xee, 0x02, 0xdf, 0x41, 0x36, 0x5d, 0x73, 0x1c, 0xc2, 0x30, 0xfe, 0x9b, 0x31, 0xa6, 0x9c, 0x91, 0x0a, 0x4c, 0x0b, 0xc9, 0xe5, 0x49, 0x7c, 0x44, 0x9b, 0xfb, 0x9f
 };


ZKN_CHECK(zkn_encode_group_commitmentHash(&curve, commitmentlist_be, 3, H));//as expected by Nano





ZKN_CHECK(cx_bn_export(H, out+32, 32));

ZKN_CHECK(cx_bn_unlock());

io_send_response_pointer(out, 32, SW_OK);

ZKN_ERROR_CLOSE_SEND();

}

 
//apdu to test group commitment
//challenge computation fail, problem is that message is greater than order
int handler_cmd_GroupCommitment(buffer_t *cdata){


ZKN_ERROR_INIT();

  uint8_t out[256];
  
  ZKN_CHECK(cx_bn_lock(32, 0));
  zkn_edcurve_t curve;
  uint32_t curveID=cdata->ptr[0];
  
  ZKN_CHECK(tEdwards_Curve_alloc_init(&curve, curveID));
 
  zkn_edpoint_t R;
  ZKN_CHECK(tEdwards_alloc(&curve, &R));


 uint8_t commitmentlist_be[32*15]={//corresponding  big endian, unpacked
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,

  0x27, 0x26, 0xa4, 0x8e, 0xb3, 0x26, 0x81, 0x68, 0x3a, 0xed, 0x12, 0x72, 0xb9, 0x83, 0xeb, 0x81, 0xfa, 0x4a, 0x2b, 0xb2, 0xa9, 0x72, 0xc0, 0x05, 0x8f, 0xe1, 0x3e, 0xc8, 0xe1, 0x8d, 0xa1, 0xce,
  0x07, 0x0d, 0x91, 0x64, 0x15, 0x64, 0x3f, 0xf2, 0xb6, 0x54, 0x85, 0x50, 0xd2, 0x58, 0x7d, 0xe7, 0x22, 0xfb, 0x74, 0x2e, 0xe1, 0x43, 0x2b, 0x0f, 0x62, 0xd9, 0xda, 0x61, 0x9c, 0x05, 0x82, 0xd9,
  0x05, 0x73, 0xed, 0x32, 0xdc, 0x42, 0x28, 0x36, 0xe9, 0xde, 0x7d, 0x67, 0x6c, 0x3f, 0x65, 0x0e, 0x30, 0x4d, 0x34, 0x12, 0xdd, 0x89, 0x3d, 0x8a, 0xde, 0x31, 0x17, 0xf7, 0x4c, 0x00, 0xcd, 0xfe,
  0x0e, 0xa2, 0x03, 0xee, 0x21, 0x98, 0xd4, 0xaf, 0xa2, 0xdd, 0x01, 0x4e, 0x4e, 0x2d, 0xa4, 0x4a, 0x23, 0x0d, 0xc0, 0xe5, 0x4f, 0xb5, 0xe3, 0xc8, 0x2c, 0x91, 0x5b, 0x5c, 0x57, 0xd6, 0xe6, 0xcb,
  
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
  0x19, 0x31, 0xd9, 0xc9, 0x44, 0x13, 0xfc, 0x3b, 0xdf, 0x25, 0xee, 0xcd, 0xc0, 0x5b, 0xb6, 0xb4, 0x92, 0xb5, 0xcb, 0xcc, 0x39, 0x49, 0x42, 0xa3, 0x6c, 0x1e, 0x55, 0x27, 0xe8, 0xcd, 0x33, 0xe5,
  0x1e, 0x4c, 0x34, 0x60, 0xf4, 0x34, 0xf4, 0x34, 0xd7, 0x21, 0xc8, 0x14, 0xbd, 0x3e, 0xa0, 0xcd, 0xcf, 0xf1, 0xef, 0xbf, 0x84, 0xc6, 0xc3, 0x1f, 0x95, 0xec, 0x8f, 0x10, 0x7f, 0x06, 0x74, 0x7f,
  0x15, 0xa9, 0xb2, 0x3d, 0x7d, 0x65, 0x17, 0x3f, 0x20, 0xb7, 0x4a, 0x90, 0xfb, 0x0e, 0x36, 0xc7, 0x5c, 0xc9, 0xca, 0x6b, 0xb9, 0x36, 0x7b, 0x0b, 0x9f, 0x81, 0x34, 0x6a, 0x65, 0x40, 0xab, 0x85,
  0x1c, 0x0d, 0x2d, 0xd8, 0x69, 0xe7, 0x10, 0xf8, 0xb2, 0x02, 0x8f, 0xf4, 0x48, 0x6b, 0x89, 0x82, 0xff, 0x9c, 0x3b, 0x17, 0x84, 0x6a, 0x3c, 0xd9, 0x68, 0x33, 0x14, 0xfd, 0xef, 0x9e, 0x4a, 0x77,
  
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
  0x06, 0xc9, 0xab, 0x14, 0xe1, 0xee, 0x4a, 0x61, 0x56, 0x1c, 0xa3, 0x32, 0xaf, 0xec, 0xe4, 0xa2, 0x98, 0x77, 0x69, 0xc3, 0xb5, 0xe7, 0x9b, 0x4b, 0xca, 0xda, 0x59, 0xc3, 0x47, 0x7f, 0xc8, 0xb1,
  0x1b, 0x15, 0x6f, 0xf4, 0x2e, 0x7f, 0x41, 0xe0, 0x2a, 0xbe, 0x29, 0x64, 0x0e, 0x2f, 0xe3, 0x90, 0xd9, 0x5a, 0x3b, 0xa8, 0x3d, 0x44, 0x5b, 0x20, 0x2a, 0x30, 0x5d, 0x1a, 0x6c, 0x59, 0x1f, 0xa9,
  0x26, 0xe4, 0x67, 0x6b, 0x3e, 0x78, 0xbe, 0xe5, 0x54, 0x9c, 0xb0, 0x3b, 0x45, 0x4b, 0x10, 0xff, 0x01, 0x9f, 0xfb, 0x90, 0x54, 0x88, 0x1c, 0x28, 0x1f, 0x97, 0xce, 0x9f, 0xd9, 0xc4, 0x59, 0x41,
  0x0d, 0x87, 0x3b, 0xec, 0x65, 0x89, 0x78, 0x7d, 0xa6, 0x9f, 0x22, 0x3c, 0x5e, 0xcd, 0xd3, 0x63, 0x52, 0x6c, 0x20, 0xa0, 0xa8, 0x23, 0x2b, 0x48, 0x49, 0xad, 0x94, 0xa5, 0x32, 0x81, 0xb1, 0x74,
  
 };


 //483618269037694980229064346324811212855951226279158177941622979891009976215
 //407396753974914637290313213687539317599476990743101461636049426358628792900
 //1065159865211878039457459247522752656156769676044497064826206794927389696879
//0111b7de94bc0994cdb268fdbfed48d491ea13d3461c316e0b252182ef107797
//00e6941174c57d0f5480719b0f5d5a5c40889f033c29241141ec849a042c3a44
//025adbef3c2f0b258853ec733e6e9d9cff584a69f335da5bbd99d12e3e12636f

 uint8_t binding_factors[96]={
    0x01, 0x11, 0xb7, 0xde, 0x94, 0xbc, 0x09, 0x94,
    0xcd, 0xb2, 0x68, 0xfd, 0xbf, 0xed, 0x48, 0xd4,
    0x91, 0xea, 0x13, 0xd3, 0x46, 0x1c, 0x31, 0x6e,
    0x0b, 0x25, 0x21, 0x82, 0xef, 0x10, 0x77, 0x97,
    0x00, 0xe6, 0x94, 0x11, 0x74, 0xc5, 0x7d, 0x0f,
    0x54, 0x80, 0x71, 0x9b, 0x0f, 0x5d, 0x5a, 0x5c,
    0x40, 0x88, 0x9f, 0x03, 0x3c, 0x29, 0x24, 0x11,
    0x41, 0xec, 0x84, 0x9a, 0x04, 0x2c, 0x3a, 0x44,
    0x02, 0x5a, 0xdb, 0xef, 0x3c, 0x2f, 0x0b, 0x25,
    0x88, 0x53, 0xec, 0x73, 0x3e, 0x6e, 0x9d, 0x9c,
    0xff, 0x58, 0x4a, 0x69, 0xf3, 0x35, 0xda, 0x5b,
    0xbd, 0x99, 0xd1, 0x2e, 0x3e, 0x12, 0x63, 0x6f
};

  ZKN_CHECK(zkn_compute_group_commitment(&curve, commitmentlist_be, binding_factors, 3, &R));
 //expected: 16161170303164183825979607281245769479057948249769186011745523858880989121576n  8565288628216469417186333805300885775780167223011702564876168413123614270872n
 //0x23bae5f2e874f9846b4893128306f7fc6020fa51a1c9e2fbcb8334bf46ae4c28, tested ok visually as correct apdu return
 ZKN_CHECK(tEdwards_export(&curve, &R, out, out+32));

 
 ZKN_CHECK(cx_bn_unlock());
 io_send_response_pointer(out, 64, SW_OK);

 ZKN_ERROR_CLOSE_SEND();
}



 
//apdu to test both group commitment
//from file 31102025, bindingfactors computation fail, unknown origin
int handler_cmd_BindingFactors(buffer_t *cdata){


ZKN_ERROR_INIT();

  uint8_t out[256];
  
 
  ZKN_CHECK(cx_bn_lock(32, 0));
  zkn_edcurve_t curve;
  uint32_t curveID=cdata->ptr[0];
  
  ZKN_CHECK(tEdwards_Curve_alloc_init(&curve, curveID));
 

  cx_bn_t H;

  ZKN_CHECK(cx_bn_alloc(&H,32));
 
  zkn_edpoint_t R;
  ZKN_CHECK(tEdwards_alloc(&curve, &R));

 

 uint8_t commitmentlist_be[32*15]={//corresponding  big endian, unpacked, as generated by vector3102025
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
0x2f, 0x65, 0xde, 0xcd, 0xd6, 0xb3, 0x79, 0x0f, 0x86, 0x63, 0x99, 0xd9, 0x10, 0x3b, 0xda, 0x21, 0x41, 0x27, 0xd8, 0x11, 0xdb, 0xb4, 0x19, 0x41, 0xbf, 0x57, 0xc0, 0x23, 0x62, 0xff, 0x72, 0x5f,
  0x19, 0x8c, 0x9e, 0xe9, 0xb3, 0x56, 0xa2, 0x16, 0x04, 0xd6, 0x4d, 0x1f, 0x3d, 0x26, 0x2c, 0x9e, 0xd6, 0x9e, 0xb6, 0x4a, 0x4f, 0x63, 0x40, 0x45, 0xec, 0x5f, 0xe1, 0x04, 0xb5, 0x3c, 0x60, 0x0c,
  0x14, 0x31, 0x5f, 0xda, 0x5a, 0x73, 0xb9, 0x76, 0x27, 0xbc, 0x9e, 0x19, 0x21, 0x39, 0xf1, 0x81, 0x0b, 0xcd, 0x71, 0x42, 0x51, 0x89, 0x90, 0x44, 0xa1, 0x67, 0x99, 0x18, 0xcf, 0x1b, 0xfd, 0x7c,
  0x13, 0xc9, 0x3e, 0x79, 0x1d, 0x47, 0xe6, 0x86, 0x7c, 0x3b, 0x79, 0x98, 0x2c, 0xc3, 0x62, 0x15, 0x21, 0xef, 0xd6, 0xae, 0x6e, 0xb8, 0x22, 0x58, 0xaa, 0xb0, 0x8a, 0xbe, 0x24, 0x61, 0x76, 0x88,

  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
 0x22, 0xea, 0x78, 0xef, 0xd9, 0x2c, 0x69, 0x70, 0xb2, 0x6f, 0xfa, 0x23, 0x1f, 0x04, 0x40, 0x77, 0x45, 0xd1, 0x3c, 0x6a, 0xff, 0x18, 0x73, 0x83, 0x38, 0xf5, 0xf6, 0xbb, 0x79, 0x05, 0xe2, 0xdb,
  0x1b, 0x1f, 0x81, 0xc6, 0x20, 0x83, 0x0d, 0x0d, 0xf3, 0xde, 0xcc, 0xce, 0x2d, 0x17, 0x73, 0xc4, 0xe8, 0xc4, 0xe6, 0xd8, 0xa3, 0x40, 0x8a, 0x0c, 0xde, 0x82, 0xef, 0x20, 0x5c, 0x24, 0xed, 0x3c,
  0x10, 0x0c, 0xdc, 0x9a, 0x71, 0xba, 0xe3, 0x8f, 0x77, 0xde, 0x03, 0x53, 0x4d, 0xba, 0xf7, 0xdb, 0x65, 0x6f, 0xf6, 0x58, 0xb7, 0x09, 0xc7, 0x92, 0xa7, 0xc6, 0x21, 0x2e, 0x20, 0x7c, 0x23, 0x05,
   0x06, 0x6d, 0xcb, 0xe6, 0x7c, 0xf5, 0x1e, 0xa4, 0xec, 0xbc, 0x38, 0x1e, 0xc7, 0x42, 0x60, 0x67, 0xfa, 0x6b, 0x63, 0x43, 0x3e, 0x1d, 0xbb, 0xdf, 0xc8, 0x7d, 0xd9, 0xcb, 0xa0, 0x7c, 0x5f, 0x81,
   
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
   0x08, 0x2b, 0x77, 0x9a, 0xc9, 0x32, 0x07, 0x91, 0x6a, 0xa0, 0x73, 0x7b, 0x48, 0x88, 0x96, 0x6b, 0x99, 0x02, 0x2f, 0x9d, 0xc3, 0xde, 0x58, 0xb9, 0x39, 0x84, 0x4a, 0x7f, 0xdd, 0x2b, 0xe5, 0x11,
   0x03, 0x1d, 0x6b, 0x98, 0x70, 0xe9, 0x85, 0xe8, 0x56, 0x94, 0x8d, 0x02, 0xc3, 0x22, 0x78, 0x24, 0xb4, 0x60, 0x20, 0xa7, 0x2c, 0x1a, 0xbb, 0x61, 0xd4, 0x24, 0x1a, 0x8b, 0x80, 0x17, 0xc1, 0x64,
   0x1f, 0x18, 0xd4, 0xbe, 0x17, 0x62, 0xfc, 0x07, 0x0d, 0x97, 0x28, 0x4e, 0xe6, 0xa2, 0xdd, 0x8e, 0xd4, 0x00, 0xa6, 0x0d, 0x61, 0x7e, 0x3e, 0x68, 0x76, 0x8b, 0xcf, 0x30, 0xb6, 0x99, 0x1c, 0x7d,
   0x15, 0xeb, 0x5f, 0xcb, 0x5a, 0x8c, 0x94, 0xc1, 0x3d, 0x3d, 0xe3, 0xb0, 0xd4, 0xe4, 0x48, 0xb9, 0x28, 0x9e, 0xbc, 0xf2, 0x98, 0x3e, 0xed, 0xe7, 0x66, 0x69, 0x23, 0x7d, 0x7c, 0xb8, 0x30, 0x6a
 };
 

 ZKN_CHECK(zkn_encode_group_commitmentHash(&curve, commitmentlist_be, 3, H));//expected:=1205238947532932168071510778307054155277611033485459647337653132783141683950n , 
// 0x2aa241d2c208ffc9a650d936f07496cae1494bc886f7c4bd816dfb6be5682ee tested ok
 ZKN_CHECK(cx_bn_export(H, out, 32));

 uint8_t PKc[32]={0x0b, 0x82, 0xb7, 0x39, 0xe7, 0x8d, 0xda, 0x57, 0xe7, 0x5a, 0xc6, 0x80, 0xef, 0x68, 0x9d, 0xf1, 0x15, 0x8f, 0xe3, 0xee, 0xd8, 0x09, 0x5c, 0x6d, 0x4b, 0xd1, 0xb2, 0xc7, 0xc1, 0x66, 0xee, 0xfd};
 //GroupKey: [  13582435537741436768206717042698308903910852672665174974848480896166461445094n,   5206396033521037211068543447749296546343896381553902592630312180141655518973n ]=x, 0xb82b739e78dda57e75ac680ef689df1158fe3eed8095c6d4bd1b2c7c166eefd

 //msg : 632122896911173630985895856078627264573909718257953237535043316012069474393n=0x165c4d55f4417b368e95a54001a30323cb04fe8343e5ad484452363a598d059
 uint8_t msg_be[32]={ 0x01, 0x65, 0xc4, 0xd5, 0x5f, 0x44, 0x17, 0xb3, 0x68, 0xe9, 0x5a, 0x54, 0x00, 0x1a, 0x30, 0x32, 0x3c, 0xb0, 0x4f, 0xe8, 0x34, 0x3e, 0x5a, 0xd4, 0x84, 0x45, 0x23, 0x63, 0xa5, 0x98, 0xd0, 0x59 };
 uint8_t msg_le[32]={0x59, 0xd0, 0x98, 0xa5, 0x63, 0x23, 0x45, 0x84, 0xd4, 0x5a, 0x3e, 0x34, 0xe8, 0x4f, 0xb0, 0x3c, 0x32, 0x30, 0x1a, 0x00, 0x54, 0x5a, 0xe9, 0x68, 0xb3, 0x17, 0x44, 0x5f, 0xd5, 0xc4, 0x65, 0x01};

 //uint8_t bindingfactors[32*3];

//expected: bindingFactor: 1489248042235379908110636752704823171186739752131294503416508302863780506739n, 2284175265225797812332353609562553878775900395642308590360772965786623749450n, 1790387453262007054201498678314355107674640357531519973440427792660137618879n
 //0x34ae26ffb4944666345ec7b443fcc92bb3652daa94ff992e17729a6fed36c73, 0x50ccc216e23f285d6068934c86746067298c1e8659a870ffe1fd1a05c9d2d4a, etc.
 
 ZKN_CHECK(zkn_compute_binding_factors(&curve, PKc, commitmentlist_be, 3, msg_le, sizeof(msg_le), out+32));
 
 ZKN_CHECK(zkn_compute_group_commitment(&curve, commitmentlist_be, out+32, 3, &R));//ok
 //expected:(5491202263201000947399037769994017886860533401948480835095292243015883477505n,8520239981579151908874486378626688704481119593263257320883372371149152897991n)
 //=0xc23e90c17e506b5faabeaea90e92fd714a82bb0ddafe5124c104e22ffced201, 0x12d648f173374f7dddb78972e6c6c5ee7dc8844e3f2768a4ced3f60c34c8cbc7, tested ok
 ZKN_CHECK(tEdwards_export(&curve, &R, out+128, out+160));

 //GroupKey: [ 13582435537741436768206717042698308903910852672665174974848480896166461445094n,5206396033521037211068543447749296546343896381553902592630312180141655518973n]=0x1e0762d6610a0b47f3b5e3f23f5f748fde5abb8843f33cf084c0dabd8dc813e6, 0xb82b739e78dda57e75ac680ef689df1158fe3eed8095c6d4bd1b2c7c166eefd
 uint8_t groupkey_be[64]={
  0x1e, 0x07, 0x62, 0xd6, 0x61, 0x0a, 0x0b, 0x47, 0xf3, 0xb5, 0xe3, 0xf2, 0x3f, 0x5f, 0x74, 0x8f, 0xde, 0x5a, 0xbb, 0x88, 0x43, 0xf3, 0x3c, 0xf0, 0x84, 0xc0, 0xda, 0xbd, 0x8d, 0xc8, 0x13, 0xe6,
  0x0b, 0x82, 0xb7, 0x39, 0xe7, 0x8d, 0xda, 0x57, 0xe7, 0x5a, 0xc6, 0x80, 0xef, 0x68, 0x9d, 0xf1, 0x15, 0x8f, 0xe3, 0xee, 0xd8, 0x09, 0x5c, 0x6d, 0x4b, 0xd1, 0xb2, 0xc7, 0xc1, 0x66, 0xee, 0xfd
  } ;


 ZKN_CHECK(compute_challenge(&curve,  &R, groupkey_be,  msg_be, 32, H));
 ZKN_CHECK(cx_bn_export(H,out+192, 32));

 
 cx_bn_t HredQ;
 cx_bn_t bn_order;
 
 uint8_t order[32]={0x06, 0x0c, 0x89, 0xce, 0x5c, 0x26, 0x34, 0x05, 0x37, 0x0a, 0x08, 0xb6, 0xd0, 0x30, 0x2b, 0x0b, 0xab, 0x3e, 0xed, 0xb8, 0x39, 0x20, 0xee, 0x0a, 0x67, 0x72, 0x97, 0xdc, 0x39, 0x21, 0x26, 0xf1};
                   
 ZKN_CHECK(cx_bn_alloc(&HredQ, 32));
 ZKN_CHECK(cx_bn_alloc_init(&bn_order, 32, order, 32));
 
 
 ZKN_CHECK(cx_bn_reduce(HredQ, H, bn_order));

 //expected mod q:199315710276320881733236870036898743016621863034597152081329332809364553563n   =  0x70cf0695b918fb1ece2c821dfeb7781b3fe86ef01a437d17a6177525b23f5b
 //ZKN_CHECK(cx_bn_export(H,out+192, 32));
 ZKN_CHECK(cx_bn_export(HredQ,out+224, 32));

 io_send_response_pointer(out, 256, SW_OK);//contains commitmentHash + 3 binding factors + challenge

 
 
 ZKN_CHECK(cx_bn_unlock());
 ZKN_ERROR_CLOSE_SEND();
}


 